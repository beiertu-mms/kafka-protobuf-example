/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package de.beiertu.kafka.protobuf.example

import de.beiertu.kafka.protobuf.example.config.Config
import de.beiertu.kafka.protobuf.example.kafka.DefaultEventProducer
import de.beiertu.kafka.protobuf.example.kafka.EventProducer
import de.beiertu.kafka.protobuf.example.streams.DefaultStreams
import de.beiertu.kafka.protobuf.example.streams.Streams
import de.beiertu.protobuf.AllTypes
import de.beiertu.protobuf.Order
import de.beiertu.protobuf.Person
import org.slf4j.LoggerFactory
import java.util.UUID
import kotlin.random.Random

class App {
    companion object {
        private val log = LoggerFactory.getLogger(App::class.java)

        private val producer: EventProducer by lazy { DefaultEventProducer(Config) }
        private val streams: Streams by lazy { DefaultStreams(Config) }

        @JvmStatic
        fun main(args: Array<String>) {
            UUID.randomUUID().toString().let { key ->
                listOf(
                    AllTypes.OrderEvents.newBuilder()
                        .setPerson(
                            Person.newBuilder()
                                .setName("Tung-$key")
                                .setAge(30)
                                .setGender(Person.Gender.MALE)
                                .build()
                        )
                        .build(),

                    AllTypes.OrderEvents.newBuilder()
                        .setOrder(
                            Order.newBuilder()
                                .setId("UID-$key")
                                .setNumber("${Random.nextLong()}")
                                .setCountry("DE")
                                .setBrand(Order.Brand.MEDIA_MARKT)
                                .build()
                        )
                        .build()
                ).forEach { message ->
                    producer
                        .publish(Config.inputTopic, key, message)
                        ?.let {
                            log.info("published event on topic=${it.topic()}, partition=${it.partition()}, offset=${it.offset()}")
                        }
                }
            }

            Thread.sleep(500)

            try {
                streams.setUncaughtExceptionHandler { _, e ->
                    log.error("got uncaught streams error", e)
                }
                streams.start()
                    .also { log.info("streams started") }
                Thread.sleep(3000)
            } catch (e: Exception) {
                log.error("streams failed", e)
                streams.close()
            } finally {
                log.info("closing streams")
                streams.close()
            }
        }
    }
}
